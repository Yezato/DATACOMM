# Signals
## Introduction
Signals are used to emit notifications for processes to take action in response to often unpredictable events. These may be caused from within a process itself, or from external events such as other processes. Many signals are fatal and result in process termination. However, death sometimes can be averted if program designers decide to handle (subvert) certain termination signals. Furthermore, many signals are more benign and are just informative or request other kinds of actions. It is possible to send signals (including those that induce termination) from the command line using kill, killall and pkill.

## Learning Objectives
By the end of this chapter, you should be able to:

Explain what signals are and how they are used. Discuss the available signals and types of signals available in Linux. Use kill, killall and pkill to send signals from the command line.

# What Are Signals?
Signals are one of the oldest methods of Inter-Process Communication (IPC) and are used to notify processes about asynchronous events (or exceptions).

By asynchronous, we mean the signal-receiving process may:
- Not expect the event to occur.
- Expect the event, but not know when it is most likely to occur.
  
For example, if a user decides to terminate a running program, it could send a signal to the process through the kernel to interrupt and kill the process.

There are two paths by which signals are sent to a process:

- From the kernel to a user process, as a result of an exception or programming error.
- From a user process (using a system call) to the kernel which will then send it to a user process. The process sending the signal can actually be the same as the one receiving it.

Signals can only be sent between processes owned by the same user or from a process owned by the superuser to any process.

When a process receives a signal, what it does will depend on the way the program is written. It can take specific actions, coded into the program, to handle the signal or it can just respond according to system defaults. Two signals:

- SIGKILL (#9)
- SIGSTOP (#19)
cannot be handled and will always terminate the program.

# Types of Signals
There are a number of different types of signals, and the particular signal sent by the kernel indicates what type of event (or exception) occurred. Generally, signals are used to handle two things:

- Exceptions detected by hardware (such as an illegal memory reference)
- Exceptions generated by the environment (such as the premature death of a process from the user's terminal).

To see a list of the signals in Linux, along with their numbers, do kill -l (that is the letter "l" not a one, "1"), as reflected in this screenshot. The meaning attached to the signal type indicates what event occurred causing the signal to be sent to a process (when sent from the kernel).
![image](https://github.com/Yezato/DATACOMM/assets/95903200/e42ba1aa-bfff-47fa-9fc4-e4774e515fca)

Available Signals

The signals from SIGRTMIN on are termed real-time signals and are a relatively recent addition. They have no predefined purpose, and differ in some important ways from normal signals; they can be queued up and are handled in a FIFO (First In First Out) order.

The meaning attached to the signal type indicates what event caused the signal to be sent (when sent from the kernel). While users can explicitly send any signal type to one of their processes, the meaning attached may no longer be implied by the signal number or type, and can be used in any way that the process desires.

Typing man 7 signal will give further documentation.

Table: Available Signals for the x86 Platform
![image](https://github.com/Yezato/DATACOMM/assets/95903200/243dbae5-f436-485e-864f-f4fe06b86783)

# kill
Since a process cannot send a signal directly to another process, it must ask the kernel to send the signal. Users (including the superuser) can send signals to other processes (programs) by using kill.

kill is really a bad name. Although it is used a lot to kill processes, it is really designed to send signals to processes. Therefore, kill is not really accurate.

The default signal sent is SIGTERM (#15) which can be handled, or ignored by the receiving process in order to prevent its death. It is preferable to use this signal to give the process a chance to clean up after itself. If this signal is ignored, the user can usually send a SIGKILL (#9) signal, which cannot be ignored, to kill the process.

We use kill to send signals (by either number or name):
```lua
kill 1234
```
```lua
kill -9 1234
```
```lua
$ kill -SIGTERM 1234
```

# killall and pkill
Checking running proccess at system
```lua
ps aux 
```
Filter process bash using grep
```lua
ps aux | grep "bash"
```
killall kills all processes with a given name, assuming the user has sufficient privilege. It uses a command name rather than a process ID, and can be done as in:
```lua
killall bash
```
```lua
killall -9 bash
```
```lua
killall -SIGKILL bash
```
pkill sends a signal to a process using selection criteria:

> pkill [-signal] [options] [pattern]
- -P: ppid
- -G: gid
- -U: uid

pkill is similar to kill but uses name instead of pid.

It also makes rsyslog reread its configuration file; for example:
```lua
pkill -HUP rsyslogd
```
